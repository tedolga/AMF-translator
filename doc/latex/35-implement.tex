\chapter{Программная реализация модуля}

\section{Выбор технических средств решения задачи}

 Как показали результаты обзора существующих тестовых фреймворков, на данный момент нет решения польностью
 удовлетворяющего поставленным требованиям. Однако многие рассмотренные программные комплексы уже предоставляют часть
 необходимого нам функционала, поэтому для решения поставленной на дипломный
 проект задачи нет необходимсти создавать тестовую утилиту с нуля, разумнее
 будет выбрать одно из существующих решений, и доработать его.
 Чтобы выбрать из предложенного разнообразия подходящий продукт, составим таблицу, где укажем, в какой степени каждый
  тестовый фреймворк удовлетворяет поставленным требованиям.

  ТУТ ТАБЛИЦА

  Анализ показал, что оптимальным выбором, в наибольшей степени удовлетворяющим поставленным требованиям, является
  Apache JMeter. Именно на базе его функционала будет реализовано решение задачи дипломногот проекта.

  Разработка модуля будет осуществляться с использованием языка Java, что обусловлено одним из требований технического
  задания - кросплатформенность приложения. Программы на Java транслируются в байт-код, выполняемый виртуальной машиной
   Java (JVM) — программой, обрабатывающей байтовый код и передающей инструкции оборудованию как интерпретатор, что
   обеспечивает полную независимости байт-кода от операционной системы и оборудования и позволяет выполнять
   Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Также выбранный нами
   тестовый фреймворк Apache JMeter является стопроцентным Java приложением, поэтому для интеграции с ним целесообразно
   использовать именно этот язык.

На текущий момент основным средством обеспечения взаимодействия Flex клиентов с Java приложениями является технология
BlazeDS --- серверная Java-технология для передачи данных, поддерживающая AMF протокол. BlazeDS является бесплатным
приложением с открытым исходным кодом,разработано компанией Adobe. В силу распространённости BlazeDS, одно из основных
функциональных требований к реализации модуля---обработка AMF сообщений--- будет решаться с помощью средств именно
этой техноогии.

В качестве инструмента автоматизации сборки проектов был выбран Apache Maven  фреймворк для автоматизации сборки
проектов, специфицированных на XML-языке POM (Project Object Model).Основныvb преимуществами Maven являются:

\begin{enumerate}
\item Независимость от OS. Сборка проекта происходит в любой операционной системе. Файл проекта один и тот же.
\item Управление зависимостями. Редко какие проекты пишутся без использования сторонних библиотек(зависимостей), которые
 зачастую тоже в свою очередь используют библиотеки разных версий. Мавен позволяет управлять такими сложными
 зависимостями, что позволяет разрешать конфликты версий и в случае необходимости легко переходить на новые версии
 библиотек.
\item Возможна сборка из командной строки. Такое часто необходимо для автоматической сборки проекта на сервере
(Continuous Integration).
\item Хорошая интеграция с средами разработки. Основные среды разработки на java легко открывают проекты которые
собираются c помощью maven. При этом зачастую проект настраивать не нужно - он сразу готов к дальнейшей разработке.
Как следствие - если с проектом работают в разных средах разработки, то maven удобный способ хранения настроек.
Настроечный файл среды разработки и для сборки один и тот же - меньше дублирования данных и соответственно ошибок.
\item Декларативное описание проекта. B файлах проекта pom.xml содержится его декларативное описание, а не отдельные
команды.
\end{enumerate}

Эффективность разработки программного обеспечения в любом современном проекте подразумевает возможность вести
разработку параллельно с другими участниками проекта.Для оптимизации совместной работы над дипломным проектом было
принято решение о размещении всех файлов проекта в репозитории системы контроля версий Git. Git—это быстрая,
масштабируемая, распределенная система управления версиями с большим набором команд, которые обеспечивают как
операции верхнего уровня, так и полный доступ к внутренним механизмам.

В качестве среды разработки бал выбрана IntellijIdea. http://www.ozon.ru/context/detail/id/2331312/

\section{Реализация поддержки AMF протокола}

\subsection{Общие сведения о BlazeDS}
BlazeDS -серверная Java-технология для передачи данных. Предоставляет ряд сервисов, которые позволяют приложениям 
клиента взаимодействовать с сервером, а также осуществяет передачу данных между несколькими клиентами, подключенными 
к серверу BlazeDS, в режиме реального времени.BlazeDS приложение состоит из двух частей: клиентского приложения и серверного 
J2EE web-приложения. Данная архитектура представлена на следующем рисунке

ТУТ РИСУНОК

Клиентское приложение BlazeDS обычно представляет собой Adobe Flex или AIR приложение. В его состав входят: 

\begin{enumerate}
\item Пользовательский интерфейс приложения. Создаётся с помощью Flex SDK;
\item Один или несколько компонентов BlazeDS: 
\begin{enumerate}
\item RemoteObject --- компонент, предоставляющий клиентскому приложению доступ к методам Java-объектов на стороне сервера; 
\item HTTPService --- компонент, позволяющий клиентскому приложению с помощью http запросов взаимодействовать с JSP, сервлетами, 
ASP страницами через сервер BlazeDS;
\item WebService --- компонент, предназанченный для взаимодействия с веб-сервисами;
\item Producer --- компонент-отправитель сообщений, предназанчен для взаимодействия с сервером сообщений;
\item Consumer --- компонент-получатель сообщений, предназанчен для взаимодействия с сервером сообщений.
\end{enumerate}
\item Набор каналов. На стороне клиента определяются каналы,которые инкапсулируют соединение между Flex клиентом и сервером 
BlazeDS. Для клиентского приложения задаётся набор каналов, упорядоченных по предпочтению. Flex компонент пытается подключиться 
по первому каналу, указанному в списке, и в случае неудачи выбирает следующий канал и т.д, до тех пор пока соединение не будет 
установлено, либо список каналов не кончится.Flex клиенты могут использовать различные типы каналов, такие как AMFChannel и 
HTTPChannel. AMFChannel использует бинарный AMF протокол, а HTTPChannel - небинарный формат AMFX (AMF, преобразованный в XML). 
Выбор канала зависит от ряда факторов, например от типа создаваемого приложения, формата передачи данных, требуемого размера 
сообщений.
\end{enumerate}

Архитектура сервера BlazeDS представлена на ...

Тут  РИСУНОК

BlazeDS сервер базируется на технологии J2EE. Взаимодействие клиента и сервера BlazeDS происхоит следующим 
образом : Flex клиент посылает запрос по определённому каналу, далее запрос направляется в соответствующий каналу 
компонент endpoint, который является точкой обработки получаемых сервеом сообщений различного типа. Затем сообщение 
декодируется и проходит через ряд Java-объектов - MessageBroker , Service object, Destination object и Adapter object.
 Adapter object либо обрабатывает запрос локально, либо связывается с какой-либо backend системой или 
 удалённым сервером. После запроса происходит обратный процесс.

\subsection{Сериализация и десериализация сообщений}

\subsection{AMF клиент}

В BlazeDS существует механизм, Java AMF Client, позволяющий совершать удалённые вызовы методов и обрабатывать ответы
сервера. Преимущество использования Java AMF Client заключается в том, что сериализация и десериализация AMF сообщений,
отправляемых клиентом и сервером, а также установка http соединения, полностью обеспечивается данной технологией.

Классы, реализующие функционал Java AMF Client, находятся в пакете flex.messaging.io.amf.client. Основным классом
является AMFConnection. Пример его работы показан ...

 ТУТ ПРИМЕР КОДА

AMFConnection устанавливает соединение с удалённым объектом по указанному URL с помощью метода connect().
В случае успешной установки соединения метод call() отправляет AMF запрос пользователю, в качестве параметров метод
принимает имя вызываемого на стороне сервера метода и его параметры, представленные в виде массива объектов.

В данном примере возможно появление двух видов исключительных ситуаций:

\begin{enumerate}
\item ServerStatusException --- в случае появления сообщения об ошибке от сервера.
\item ClientStatusException --- в случае ошибки установки соединения с сервером или при непредвиденном разрыве
соединения.
\end{enumerate}

\section{Интеграция с JMeter}

\subsection{Общая архитектура JMeter}

Структура проекта JMeter изображена на ...

ТУТ РИСУНОК

\begin{enumerate}
\item bin --- содержит в себе .bat и .sh файлы для запуска JMeter, файл ApacheJMeter.jar и файлы настроек;
\item docs --- директория, содержащая документацию по проекту;
\item extras --- дополнительне фалйлы для утилиты ant;
\item lib --- jar файлы библиотек, используемых в JMeter;
\item lib/ext --- jar файлы ядра и отдельных компонентов JMeter;
\item src --- исходные коды JMeter;
\item test --- юнит-тесты;
\item xdocs --- xml файлы для документации (JMeter генерирует документацию из xml).
\end{enumerate}

Рассмотрим подробнее содержимое директории src:

\begin{enumerate}
\item component --- директория, содержащая общие для различных протоколов элементы, такие как визуалайзеры,
соответствия и т.д;
\item core --- ядро JMeter, содержит базовые интерфейсы и абстрактные классы;
\item examples --- примеры, демонстрирующие использование компонентов фреймворка;
\item functions --- стандартные функции, используемые всеми компонентами;
\item jorphan --- утилитные классы;
\item monitor --- элементы мониторинга сервера Tomcat 5;
\item protocol --- содержит реализации компонентов Jmeter для различных протоколов.
\end{enumerate}

В архитектуре JMeter ядро, содержащее в себе интерфейсы и абстрактные классы,а также базовый функционал,
отделёны от конкретных реализаций компонентов для различных протоколов. Это сделано для того, чтобы разработчики
могли добавлять поддержку новых протоколов без сборки всего приложения. Таким образом, для того, чтобы добавить
в JMeter элементы тестирования Flex приложений, нужно будет переопределить несколько базовых
компонентов JMeter, собрать jar файл модуля, и поместить его в директорию lib/ext --- новый функционал будет
автоматически подхвачен JMeter.

Прежде чем приступить к созданию различных компонентов, опишем ряд общих правил их реализации,
которые необходимы для того, чтобы элемент правильно работал в среде JMeter. В основном это относится к
графическому интерфейсу пользователя (GUI).

В JMeter код GUI элемента отделён от функционального кода элемента, поэтому реализуя новый компонент следует
создавать отдельные классы для рабочего функционала и графического представления. GUI элемент, в зависимости
 от его предназанчения, должен расширять один из представленных ниже абстрактных классов.

\begin{enumerate}
\item AbstractSamplerGui
\item AbstractAssertionGui
\item AbstractConfigGui
\item AbstractControllerGui
\item AbstractPostProcessorGui
\item AbstractPreProcessorGui
\item AbstractVisualizer
\item AbstractTimerGui
\end{enumerate}

Следующим шагом является реализация метода getResourceLabel().Этот метод должен возвращать имя ресурса,
представляющего компонент.

Чтобы GUI создаваемого вами тестового элемента соответсвовало стилю JMeter, следует добавить в него стандартную
рамку JMeter, которая создаётся следующим образом --- setBorder(makeBorder()). Также необходимо создать
панель с именем элемента методом makeTitlePanel(). Обычно её располагают в верхней центральной части панели
элемента.

Важным пунктом является реализация метода public void configure(TestElement el), который отвечает за отображение
параметров тестового элемента в GUI. Первой строчкой в методе должен быть вызов super.configure(e), что обеспечит
выполнение некоторых стандартных действий, как например отображение имени элемента. Обратное действие ---
передача данных из GUI в тестовый элемент --- обеспечивается методом public void modifyTestElement(TestElement e),
который также нужно реализовать. В имплиментацию этого метода тоже включается строчка
super.configureTestElement(e).

Другой необходимый в создании GUI метод --- public TestElement createTestElement(). Он должен новый экземпляр
тестового элемента и передавать его в метод modifyTestElement(TestElement) в качестве параметра.

Все вышеобозначенные правила разграничения GUI и функционала элемента облегчают разработчикам реализацию графического
интерфейса. Хотя программист и не освобождается от процедуры создания и размещения компонентов графического
интерфейса, всё взаимодействие GUI и соответствующего ему тестового элемента обеспечивается JMeter.

\subsection{Реализация модуля отправки AMF сообщений}



\subsection{Реализация прокси-сервера}

\section{Руководство пользователя}

\subsection{Установка JMeter}

Для начала необходимо скачать с сайта производителя zip архив, содержащий все необходимы для установки файлы,
а затем распаковать его на диске. Место установки JMeter далее будем называть JMETER\_HOME.

\subsection{Установка модуля amf-translator}

Чтобы подключить к JMeter модуль amf-translator, достаточно добавить jar-файл приложения в каталог JMETER\_HOME/lib/ext.

\subsection{Запуск приложения}

Приложение запускается с помощью файла jmeter.bat или ApacheJMeter.jar, находящихся в каталоге JMETER\_HOME/bin.

\subsection{Настройка прокси-сервера}

После запуска в окне приложения с левой стороны нам доступно дерево элементов. Чтобы создать прокси сервер
с поддержкой протокола AMF, необходимо правой кнопкой мыши кликнуть по элементу WorkBench,
а затем добавить элемент AMF Proxy Server (WorkBench > Add > Non-Test Elements > AMF Proxy Server).

\begin{figure}[ht]
\center{\includegraphics[height=120mm, width=160mm]{fig/development/proxySettings.png}}
\caption{Настройка прокси-сервера}
\label{ris:proxySettings.png}
\end{figure}

В поле AmfProxy Port необходимо указать номер порта, который будет слушать наш прокси сервер.
Если указать, например, 9090, то прокси-сервер будет запущен на localhost:9090.
Затем точно такие же настройки прокси-сервера устанавливаются в браузере, с помощью которого будет
производиться тестирование. Также стоит убедиться, что указанный Вами порт уже не занят другим приложением.

\subsection{Запись тестового сценария}

После того, как в AMF Proxy Server установлены все необходимые параметры, нажимается кнопка Start,
запускающая прокси-сервер.

\begin{figure}[h]
\center{\includegraphics[height=120mm, width=160mm]{fig/development/proxyStart.png}}
\caption{Запуск прокси-сервера}
\label{ris:proxyStart.png}
\end{figure}

Затем тестируемое приложение открывается в браузере, для которого также
применены соответсвующие настройки прокси-сервера, и пользователь может выполнять с Flex приложением
необходимые операции, которые будут записываться AMF Proxy Server в виде элементов AMF RPC Sampler и в
дальнейшем могут быть перенесены в тест-план. Чтобы завершить запись тестовых запросов, необходимо
нажать кнопку Stop. После завершения записи тестов, все перехваченные запросы отображаются в дереве
элементов JMeter в качестве дочерних элементов AMF Proxy Server.

\subsection{Создание тест-плана}

Создание тест-плана в JMeter осуществляется следующим образом.
В первую очередь добавляется группа потоков - Thread Group (Test Plan > Threads (Users) > Thread Group).

\begin{figure}[ht]
\center{\includegraphics[height=120mm, width=160mm]{fig/development/testplan.png}}
\caption{Создание тест-плана}
\label{ris:testplan.png}
\end{figure}

Этот элемент является ключевым в тест-плане JMeter, именно его функционал отвечает за реализацию
нагрузочного тестирования --- многопоточного запуска последовательности тестовых шагов.
В данном элементе задается следующее:

\begin{enumerate}
\item Действия, которые будут производиться в случае, если в тест выполняется с ошибкой
(Action to be taken after a Sampler error);
\item Число потоков, в которое будут запускаться шаги тест-плана (Number of Threads);
\item Интервал, в течение которого будет запущено указанное в предыдущем параметре
число потоков (Ramp-Up Period);
\item Число повторений набора тестов (Loop Count);
\item Расписание запуска тестов (Scheduler).
\end{enumerate}

Затем в Thread Group в качестве дочерних элементов добавляются шаги тестов, которые
будут запускаться с указанными характеристиками. В нашем случае мы переносим элементы
AMF RPC Sampler, записанные с помощью прокси.

AMF RPC Sampler представляет собой форму для вызова процедур java-объектов на стороне
сервера. Чтобы вызвать метод удалённого объекта, необходимо заполнить следующие
поля: 

\begin{enumerate}
\item Endpoint Url - URL, по которому отправляется запрос
\item AMF Call - имя удалённого объекта и процедуы, которая должна быть вызвана; 
Например, если мы хоти вызвать у объекта registrationDestionation метод registerUser, 
в этом поле следует написать registrationDestination.registerUser;
\item Request Parameters - параметры метода, вызываемого у объекта (если они 
существуют).
\end{enumerate}

На Рис.~\ref{ris:amfSampler.png} представлен интерфейс AMF RPC Sampler.
\begin{figure}[ht]
\center{\includegraphics[height=120mm, width=160mm]{fig/development/amfSampler.png}}
\caption{Интерфейс элемента AMF RPC Sampler}
\label{ris:amfSampler.png}
\end{figure}
 
Помимо сэмплера в тест-план также следует добавить визуалайзер результатов, чтобы иметь возможность
отслеживать ход тестового сценария (Thread Group > Add > Listener ).
JMeter предлагает большой выбор таких элементов, для примера будем использовать View Results Tree.
После того как план сформирован, он может быть сохранён. (File > Save Test Plan As...)

\subsection{Запуск тестов}

Чтобы запустить содержимое элемента Test Plan, необходимо выбрать в основном меню Run > Start.
После заврешения прогона тестов результаты их выполнения можно наблюдать в View Results Tree.

\begin{figure}[ht]
\center{\includegraphics[height=110mm, width=160mm]{fig/development/testResults.png}}
\caption{Отображение результатов тестов в визуалайзере View Results Tree}
\label{ris:testResults.png}
\end{figure}

В правой части визуалайзера отображается дерево элементов тест плана и статус 
их выполнения - если элемент подсвечен зелёным цветом, то шаг выполнен 
успешно. В случае с AMF RPC Sampler это значит, что соединение с сервером было установлено 
и вызов метода удалённого объекта прошёл без ошибок. Иначе тест не считантся пройденным и 
элемент подсвечивается красным цветом. Также на вкладках слева предоставляется 
возможность просмотра отправленного запроса и полученного от сервера ответа.  

\section{Методика тестирования}