\chapter{Проектирование и реализация модуля}

\section{Требования к разрабатываемому модулю}

\subsection{Формулировка требований}
Сформулируем ряд функциональных требований к разрабатываемому модулю. Требования должны быть составлены
таким образом, чтобы результат их реализации удовлетворял одной из поставленных на дипломный проект задаче ---
разработанное ПО должно в значительной степени снижать сложность осуществления функционального
и нагрузочного тестирования взаимодейтсвия клиента и сервера по AMF-протоколу.

\begin{enumerate}
\item Разрабатывамый модуль должен предоставлять возможность записи действий пользователя,
производимых с тестируемым приложением(проксирование AMF запросов). Проксирование является важным функциоанльным
требованием, так как на этапе подготовки тестирования позволит создавать тестовый сценарий, на основе действий
пользователя с приложением.
\item Программный модуль должен предоставлять возможность отправки AMF сообщений серверу и обработки ответов сервера.
\item Программный модуль должен полностью поддерживать протокол AMF с целью кодирования, декодирования и замены
содержимого сообщений. Все полученные или отправленные сообщения должны предоставляться пользователю в человекочитаемом
формате.
\item Реализация программного модуля должна полностью поддерживать основные прнципы нагрузочного тестирования,
имитирующего работу большого количества пользователей одновременно, применительно к Flex технологии.
\item Разрабатываемое приложение должно интегрироваться с системами автоматической сборки проектов, такими как Maven и Ant.
\item Возможность запуска тестов из командной строки. Данная возможность позволяет
выполнять тесты в автоматическом режиме в системах непрерывной интеграции, что
является необходимостью, особенно в тех случаях, когда над разными частями
тестируемой системы разработчики трудятся независимо и необходимо
выполнении частых автоматизированных сборок проекта для скорейшего
выявления и решения интеграционных проблем. Часто производители тестовых
фреймворков предоставляют свои продукты для проведения интеграционного тестирования, однако
зачастую они узко заточены под конкретный круг задач, поэтому нас будет интересовать
возможность запуска тестов на таких инструментах интеграции, как Jenkins и
Hudson, которые на данный момент широко распротранены и имеют множество плагинов, позволяющих
значительно расширить их существующую функциональность.
\item Кроссплатформенность. Созданная нами тестовая утилита должна работать
под управлением различных операционных систем.
\item Условия распростронения продукта. В идеале программное обеспечение должно быть
бесплатным и иметь открытый исходный код с возможность создания собственных расширений,
это является одним из основных критериев отбора, так как тестировщики и разработчики
всегда должны иметь возможность доработки и усовершенствования существующего функционала
тестового фреймворка, чтобы адаптировать его под специфику работы тестируемого ими приложения.
\end{enumerate}

\subsection{Анализ требований}
Проанализируем сформулированные требования к разрабатываемому модулю.

Для классификации требований были выбраны следующие критерии:

\begin{enumerate}
\item Приоритет --- критерий оценки полезности реализации требования для конечного пользователя,
важности для достижения поставленных перед проектом целей.
\item Трудоёмкость --- критерий отображает предварительную оценку сложности реализации требования,
количество привлекаемых для этого ресурсов.
\item Риск --- интегральный критерий, введением которого предпринимается попытка оценить во-первых
возможность невыполнения требования, во-вторых возможную ошибку в оценке по двум предыдущим
критериям (в первую очередь  трудоёмкости).
\end{enumerate}

Для каждого из критериев введена шкала из трёх уровней: низкий, средний, высокий.
Размерность шкалы выбрана минимальной исходя из соображений простоты и наглядности.
Так как размер проекта и количество предъявляемых к нему требований незначительны,
то таких шкал вполне достаточно для исчерпывающей классификации требований а также принятия
проектных и организационных решений.

Для наглядности и удобства сведём их в таблицу.

\begin{longtable}{|p{6cm}|p{3cm}|p{3cm}|p{2cm}|}
\caption{Список требований к модулю}
\label{tab:longtable}
\\ \hline
Описание & Приоритет & Трудоёмкость & Риск\\
\hline \endfirsthead
\subcaption{Продолжение таблицы~\ref{tab:longtable}}
\\ \hline \endhead
\hline \subcaption{Продолжение на след. стр.}
\endfoot
\hline \endlastfoot
\hline
Возможность записи действий пользователя, производимых с тестируемым приложением(проксирование AMF запросов)& Средний &
Высокая & Средний\\
\hline
Возможность отправки AMF сообщений серверу и обработки ответов сервера& Высокий & Средняя & Средний\\
\hline
Поддержка протокола AMF с целью кодирования, декодирования и замены содержимого сообщений& Высокий & Высокая & Высокий\\
\hline
Поддержка основных прнципов нагрузочного тестирования(применительно к Flex технологии) & Средний & Средний & Высокий\\
\hline
Интеграция с системами автоматической сборки проектов& Высокий & Средняя & Средний\\
\hline
Возможность запуска тестов из командной строки& Низкий & Низкая & Средний\\
\hline
Кроссплатформенность& Высокий & Низкая & Низкий\\
\hline
Условия распростронения продукта & Высокий & --- & ---\\
\hline
\end{longtable}

\section{Выбор технических средств решения задачи}

Как показали результаты обзора существующих тестовых фреймворков, на данный момент нет решения польностью
удовлетворяющего поставленным требованиям. Однако многие рассмотренные программные комплексы уже предоставляют часть
необходимого нам функционала, поэтому для решения поставленной на дипломный
проект задачи нет необходимсти создавать тестовую утилиту с нуля, разумнее
будет выбрать одно из существующих решений, и доработать его.
Чтобы выбрать из предложенного разнообразия подходящий продукт, составим таблицу, где укажем, в какой степени каждый
тестовый фреймворк удовлетворяет поставленным требованиям.

\begin{longtable}{|p{5cm}|p{3cm}|p{3cm}|p{1.7cm}|p{0.9cm}|}
\caption{Список требований к модулю}
\label{tab:longtable}
\\ \hline
&HP QuickTest Professional&IBM Rational Functional Tester&NeoLoad&JMeter\\
\hline \endfirsthead
\subcaption{Продолжение таблицы~\ref{tab:longtable}}
\\ \hline \endhead
\hline \subcaption{Продолжение на след. стр.}
\endfoot
\hline \endlastfoot
\hline
Возможность записи действий пользователя, производимых с тестируемым приложением (проксирование AMF запросов)& - & - & +
& +\\
\hline
Возможность отправки AMF сообщений серверу и обработки ответов сервера& + & + & + & +\\
\hline
Поддержка протокола AMF с целью кодирования, декодирования и замены содержимого сообщений& - & - & + & -\\
\hline
Поддержка основных прнципов нагрузочного тестирования (применительно к Flex технологии) & - & - & + & -\\
\hline
Интеграция с системами автоматической сборки проектов& - & - & - & +\\
\hline
Возможность запуска тестов из командной строки& + & + & - & +\\
\hline
Кроссплатформенность& MW & MW, Linux & MW, Linux, Solaris & CP\\
\hline
Условия распростронения продукта & PS & PS & PS &APL 2.0\\
\hline
\end{longtable}

Анализ тестовых утилит относительно поставленных требований с учётом их приоритета, трудоёмкости и риска, показал,
что оптимальным выбором, в наибольшей степени удовлетворяющим поставленным требованиям, является
Apache JMeter. Именно на базе его функционала будет реализовано решение задачи дипломногот проекта.

Разработка модуля будет осуществляться с использованием языка Java, что обусловлено одним из требований технического
задания --- кросплатформенность приложения. Программы на Java транслируются в байт-код, выполняемый виртуальной машиной
Java (JVM) --- программой, обрабатывающей байтовый код и передающей инструкции оборудованию как интерпретатор, что
обеспечивает полную независимости байт-кода от операционной системы и оборудования и позволяет выполнять
Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Также выбранный нами
тестовый фреймворк Apache JMeter является стопроцентным Java приложением, поэтому для интеграции с ним целесообразно
использовать именно этот язык.

На текущий момент основным средством обеспечения взаимодействия Flex клиентов с Java приложениями является технология
BlazeDS --- серверная Java-технология для передачи данных, поддерживающая AMF протокол. BlazeDS является бесплатным
приложением с открытым исходным кодом, разработанным компанией Adobe. В силу распространённости BlazeDS, одно из основных
функциональных требований к реализации модуля --- обработка AMF сообщений --- будет решаться с помощью средств именно
этой техноогии.

В качестве инструмента автоматизации сборки проектов был выбран Apache Maven --- фреймворк для автоматизации сборки
проектов, специфицированных на XML-языке POM (Project Object Model).Основными преимуществами Maven являются:

\begin{enumerate}
\item Независимость от OS. Сборка проекта происходит в любой операционной системе. Файл проекта один и тот же.
\item Управление зависимостями. Редко какие проекты пишутся без использования сторонних библиотек(зависимостей), которые
 зачастую тоже в свою очередь используют библиотеки разных версий. Мавен позволяет управлять такими сложными
 зависимостями, что позволяет разрешать конфликты версий и в случае необходимости легко переходить на новые версии
 библиотек.
\item Возможна сборка из командной строки. Такое часто необходимо для автоматической сборки проекта на сервере
(Continuous Integration).
\item Хорошая интеграция с средами разработки. Основные среды разработки на java легко открывают проекты которые
собираются c помощью maven. При этом зачастую проект настраивать не нужно --- он сразу готов к дальнейшей разработке.
Как следствие - если с проектом работают в разных средах разработки, то maven удобный способ хранения настроек.
Настроечный файл среды разработки и для сборки один и тот же --- меньше дублирования данных и соответственно ошибок.
\item Декларативное описание проекта. B файлах проекта pom.xml содержится его декларативное описание, а не отдельные
команды.
\end{enumerate}

Эффективность разработки программного обеспечения в любом современном проекте подразумевает возможность вести
разработку параллельно с другими участниками проекта.Для оптимизации совместной работы над дипломным проектом было
принято решение о размещении всех файлов проекта в репозитории системы контроля версий Git. Git --- это быстрая,
масштабируемая, распределенная система управления версиями с большим набором команд, которые обеспечивают как
операции верхнего уровня, так и полный доступ к внутренним механизмам.

В качестве среды разработки бал выбрана IntelliJ IDEA --- интегрированная cреда разработки программного обеспечения на
многих языках программирования, в частности Java. IntelliJ IDEA обладает широким набором интегрированных инструментов
для рефакторинга, которые позволяли программистам быстро реорганизовывать исходные тексты программ. Дизайн среды
ориентирован на продуктивность работы программистов, позволяя им сконцентрироваться на разработке функциональности,
в то время как IntelliJ IDEA берет на себя выполнение рутинных операций. Среди прочих возможностей, IntelliJ IDEA
хорошо совместима со многими популярными open source инструментами разработчиков, такими как Git, Subversion,
Apache Ant, Maven и JUnit\cite{idea-book}.

\section{Поддержка AMF протокола}

\subsection{Общие сведения о BlazeDS}

BlazeDS --- серверная Java-технология для передачи данных. Предоставляет ряд сервисов, которые позволяют приложениям
клиента взаимодействовать с сервером, а также осуществяет передачу данных между несколькими клиентами, подключенными 
к серверу BlazeDS, в режиме реального времени.BlazeDS приложение состоит из двух частей: клиентского приложения и серверного 
J2EE web-приложения. Архитектура клиента представлена на Рис.~\ref{ris:blazeDSClient.png}.

\begin{figure}[ht]
\center{\includegraphics[height=80mm, width=130mm]{fig/development/blazeDSClient.png}}
\caption{Архитектура клиента BlazeDS}
\label{ris:blazeDSClient.png}
\end{figure}

Клиентское приложение BlazeDS обычно представляет собой Adobe Flex или AIR приложение. В его состав входят: 

\begin{enumerate}
\item Пользовательский интерфейс приложения. Создаётся с помощью Flex SDK;
\item Один или несколько компонентов BlazeDS: 
\begin{enumerate}
\item RemoteObject --- компонент, предоставляющий клиентскому приложению доступ к методам Java-объектов на стороне сервера; 
\item HTTPService --- компонент, позволяющий клиентскому приложению с помощью http запросов взаимодействовать с JSP, сервлетами, 
ASP страницами через сервер BlazeDS;
\item WebService --- компонент, предназанченный для взаимодействия с веб-сервисами;
\item Producer --- компонент-отправитель сообщений, предназанчен для взаимодействия с сервером сообщений;
\item Consumer --- компонент-получатель сообщений, предназанчен для взаимодействия с сервером сообщений.
\end{enumerate}
\item Набор каналов. На стороне клиента определяются каналы,которые инкапсулируют соединение между Flex клиентом и сервером 
BlazeDS. Для клиентского приложения задаётся набор каналов, упорядоченных по предпочтению. Flex компонент пытается подключиться 
по первому каналу, указанному в списке, и в случае неудачи выбирает следующий канал и т.д, до тех пор пока соединение не будет 
установлено, либо список каналов не кончится. Flex клиенты могут использовать различные типы каналов, такие как AMFChannel и
HTTPChannel. AMFChannel использует бинарный AMF протокол, а HTTPChannel - небинарный формат AMFX (AMF, преобразованный в XML). 
Выбор канала зависит от ряда факторов, например от типа создаваемого приложения, формата передачи данных, требуемого размера 
сообщений.
\end{enumerate}

Из модели архитектуры сервера BlazeDS представленной на Рис.~\ref{ris:blazeDSServer.png}, очевидно что он базируется
на стеке на технологии J2EE.

\begin{figure}[ht]
\center{\includegraphics[height=80mm, width=130mm]{fig/development/blazeDSServer.png}}
\caption{Архитектура сервера BlazeDS}
\label{ris:blazeDSServer.png}
\end{figure}

Взаимодействие клиента и сервера BlazeDS происходит следующим образом:
Flex клиент посылает запрос по определённому каналу, далее запрос направляется в соответствующий каналу
компонент endpoint, который является точкой обработки получаемых сервером сообщений различного типа. Затем сообщение
декодируется и проходит через цепочку Java-объектов --- MessageBroker, Service object, Destination object и Adapter object.
Adapter object либо обрабатывает запрос локально, либо связывается с какой-либо backend системой или
удалённым сервером. После запроса происходит обратный процесс.
 
Блогодаря использованию модульной архитектуры для обеспечения поддержки AMF протокола в разрабатываемом
программном обеспечении, необходимо будет реализовать только модуль, осуществляющий сериализацию сообщений
перед их отправкой от клиента к серверу и наоборот, десериализацию полученных клиентом сообщений 
сервера.

\subsection{Сериализация и десериализация сообщений}

AMF --- бинарный формат, используемый для сериализации структурированных данных, таких как объекты Action Script или
XML, и обмена сообщениями между Adobe Flash клиентом и удалённым сервисом\cite{amf}. Action Message Format более экономичен
по трафику по сравнению с XML и позволяет передавать типизированные объекты. Первая версия протокола, AMF0, была 
применена в Flash Player 6 в 2001 и оставалась неизменной в реализациях ActionScript 2.0 в Flash Player 7 и Flash 
Player 8. В Flash Player 9 был внедрён Action Script 3.0 с усовершенствованной виртуальной машиной 
ActionScript Virtual Machine (AVM+). В новой версии протокола, AMF3, оптимизирован формат сообщений и введена 
поддержка новых типов. Далее будет рассматриваться именно обновлённая версия протокола.

AMF протокол поддерживает следующие типы данных:

\begin{enumerate}
\item undefined --- любой неcпецифицированный протоколом формат данных;
\item null;
\item boolean;
\item integer --- в ActionScript 3.0 integer представляет собой 29х битное число переменной длины без знака или 28 битное
со знаком. Если выделенных битов не достаточно для представления числа, то AVM+ сериализует его как тип double;
\item double --- 8ми байтовое число с плавающей точкой в формате IEEE 754 с порядком байтов от старшегок младшему
(network byte order)
\item string --- сторка в кодировке UTF-8, литерал или ссылка;
\item xml-doc --- данные в xml формате в кодировке UTF-8. При сериализации преобразуются в строку;
\item date --- сериализуется как число миллисекунд, прошедших с 00:00:00 первого января 1970 в часовом поясе UTC,
данные о локальном часовом поясе не посылаются;
\item array --- массивы данных;
\item object --- amf3 обрабатывает Action Script объекты, а также разработанные пользователем классы, которые можно
разделить на следующие группы:
\begin{enumerate}
\item анонимные --- Action Script объекты или экземпляры пользовательских классов, не имеющие зарегистрированных в
протоколе псевдонимов. В процессе десериализации анонимные объекты будут интерпретироваться как Object;
\item типизированные --- экземпляры классов с зарегистрированными в протоколе псевдонимами;
\item динамические --- экземпляры классов, общедоступные переменные которых могут динамически изменяться во время
выполнения кода;
\item сериализуемые --- экземпяры классов, реализующих интерфейс flash.utils.IExternalizable, которые полностью
контролируют сериализацию своих членов.
\end{enumerate}
\item xml --- в Action Script 3.0 введена поддержка XML синтаксиса E4X;
\item byte-array --- в Action Script 3.0 введён новый формат хранения массива байтов, ByteArray. AMF3 сериализует
данные этого типа с использованием 29ти битного значения, передаваемого в качестве длины массива байтов.
\end{enumerate} 

AMF сообщение содержит информацию об отдельной транзакции. Оно определяют вызываемую удалённую операцию, 
операцию, выполняемую клиентом в случае успеха или ошибки запроса, и используемые при этом данные. Структуры сообщений,
представляющих запросы клиента и ответы сервера, одинаковы.
 
Первым полем AMF сообщения является target URI, которое описывает, какая операция, функция или 
метод должны быть вызваны. Спецификация AMF не определяет точного формата этого поля --- его формат зависит 
от конкретной реализации используемого сервера.

Вторым полем AMF сообщения является response URI, определяющее имя операции, которая будет вызвана в зависимости от 
ответа на запрос клиента.

Третье поле AMF сообщения --- длина тела сообщения в байтах.

Четвртым заключительным полем AMF сообщения является тело сообщения. Оно содержит фактические данные, связанные 
с выполняемой операцией. Если сообщение является запросом клиента, то оно должно содержать параметры, передаваемые 
удалённому методу. Если сообщение является ответом сервера, то оно должно содержать либо ответ на запрос, либо 
сообщение об ошибке.

Отправка AMF сообщений осуществляется пакетами, какждый из которых имеет следующую структуру:

\begin{enumerate}
\item версия AMF протокола;
\item количество заголовков пакета;
\item заголовки пакета;
\item число сообщений пакета;
\item сообщения пакета;
\end{enumerate}

В библиотеке BlazeDS существует класс, соответсвующий структуре AMF пакетов --- ActionMessage. Чтобы получить экземляр 
ActionMessage из входного потока данных, используется класс AmfMessageDeserializer. Следующий код демонстрирует 
этот процесс:

\lstinputlisting[caption=Получение ActionMessage из входного потока данных]{code/deserialize.txt}
 
Метод initialize(SerializationContext context, InputStream in, AmfTrace trace) устанавливает контекст для чтения данных из 
указанного входного потока. Метод readMessage(ActionMessage m, ActionContext context) считывает десериализованные данные в 
переданный ему в качестве параметра экземпяр ActionMessage. Пример, десериализованного сообщения представлен на Рис.~\ref{ris:deserialisedMessage.png}.

\begin{figure}[ht]
\center{\includegraphics[height=60mm, width=120mm]{fig/development/deserialisedMessage.png}}
\caption{Десериализованное сообщение}
\label{ris:deserialisedMessage.png}
\end{figure} 

\subsection{AMF клиент}

В BlazeDS существует механизм, Java AMF Client, позволяющий совершать удалённые вызовы методов и обрабатывать ответы
сервера. Преимущество использования Java AMF Client заключается в том, что сериализация и десериализация AMF сообщений,
отправляемых клиентом и сервером, а также установка http соединения, полностью обеспечивается данной технологией.

Классы, реализующие функционал Java AMF Client, находятся в пакете flex.messaging.io.amf.client. Основным классом
является AMFConnection, пример использования которого приведен ниже.

\lstinputlisting[caption=Получение ActionMessage из входного потока данных]{code/amfConnection.txt}

AMFConnection устанавливает соединение с удалённым объектом по указанному URL с помощью метода connect().
В случае успешной установки соединения метод call() отправляет AMF запрос пользователю, в качестве параметров метод
принимает имя вызываемого на стороне сервера метода и его параметры, представленные в виде массива объектов.

В данном примере возможно появление двух видов исключительных ситуаций:

\begin{enumerate}
\item ServerStatusException --- в случае появления сообщения об ошибке от сервера.
\item ClientStatusException --- в случае ошибки установки соединения с сервером или при непредвиденном разрыве
соединения.
\end{enumerate}

\section{Интеграция с JMeter}

\subsection{Общая архитектура JMeter}

Структура каталогов проекта JMeter представляет собой дерево из следующих элементов:

\begin{enumerate}
\item bin --- содержит в себе .bat и .sh файлы для запуска JMeter, файл ApacheJMeter.jar и файлы настроек;
\item docs --- директория, содержащая документацию по проекту;
\item extras --- дополнительне фалйлы для утилиты ant;
\item lib --- jar файлы библиотек, используемых в JMeter;
\item lib/ext --- jar файлы ядра и отдельных компонентов JMeter;
\item src --- исходные коды JMeter;
\item test --- юнит-тесты;
\item xdocs --- xml файлы для документации (JMeter генерирует документацию из xml).
\end{enumerate}

Общая логическая структура модулей проекта расположенных в каталоге src
представлена на Рис.~\ref{ris:Diagram3.png}:

\begin{figure}[ht]
\center{\includegraphics[width=1\linewidth]{fig/development/Diagram3.png}}
\caption{Диаграмма модулей}
\label{ris:Diagram3.png}
\end{figure}

где, каждый модуль является независимой релизной группой с минимальными зависимостями от других:
\begin{enumerate}
\item component --- содержит общие для различных протоколов элементы, такие как визуалайзеры,
соответствия и т.д;
\item core --- ядро JMeter, содержит базовые интерфейсы и абстрактные классы;
\item examples --- примеры, демонстрирующие использование компонентов фреймворка;
\item functions --- стандартные функции, используемые всеми компонентами;
\item jorphan --- утилитные классы;
\item monitor --- элементы мониторинга сервера Tomcat 5;
\item protocol --- содержит реализации компонентов Jmeter для различных протоколов.
\end{enumerate}

В архитектуре JMeter ядро, содержащее в себе интерфейсы и абстрактные классы,а также базовый функционал,
отделены от конкретных реализаций компонентов для различных протоколов. Это сделано для того, чтобы разработчики
могли добавлять поддержку новых протоколов без сборки всего приложения. Таким образом, для того, чтобы добавить
в JMeter элементы тестирования Flex приложений, нужно будет переопределить несколько базовых
компонентов JMeter, собрать jar файл модуля, и поместить его в директорию lib/ext --- новый функционал будет
автоматически добавлен в JMeter.

Прежде чем приступить к созданию различных компонентов, опишем ряд общих правил их реализации,
которые необходимы для того, чтобы элемент правильно работал в среде JMeter. В основном это относится к
графическому интерфейсу пользователя (GUI). В качестве основного паттерна проектирования графического
интерфейса используется модель MVC (Model-view-controller), диаграмма отошения объектов которой предоставлена на рис.~\ref{ris:Diagram2.png}.

\begin{figure}[ht]
\center{\includegraphics[width=1\linewidth]{fig/development/Diagram2.png}}
\caption{Отношение между объектами графического интерфейса}
\label{ris:Diagram2.png}
\end{figure}

MVC --- это схема использования нескольких шаблонов проектирования, с помощью которых модель данных приложения,
пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента так, что
модификация одного из компонентов оказывает минимальное воздействие на остальные.

В JMeter код GUI элемента отделён от функционального кода элемента, поэтому реализуя новый компонент следует
создавать отдельные классы для рабочего функционала и графического представления. Графический элемент, в зависимости
от его предназанчения, должен расширять один из представленных в таблице абстрактных классов.

\begin{longtable}{|p{6cm}|p{9cm}|}
\caption{Абстрактные классы GUI JMeter}
\label{tab:longtable}
\\ \hline
Имя класса & Предназанчение\\
\hline \endfirsthead
\subcaption{Продолжение таблицы~\ref{tab:longtable}}
\\ \hline \endhead
\hline \subcaption{Продолжение на след. стр.}
\endfoot
\hline \endlastfoot
\hline
AbstractSamplerGui& Класс GUI для элемента Sampler, предназначенного для отправки запросов серверу\\
\hline
AbstractAssertionGui& Класс GUI для элемента Assertion, осуществляющего проверку результатов выполнения запроса\\
\hline
AbstractConfigGui& Класс GUI для Configuration Element, применяемого для настройки параметров Sampler\\
\hline
AbstractControllerGui& Класс GUI для элементов Controller, осуществляющих управление вызовом содержимого Test Plan\\
\hline
AbstractPostProcessorGui&Класс GUI для Pщые-Processor Element, обозначающего действия, которые должны быть выполнены
после отправки запроса\\
\hline
AbstractPreProcessorGui& Класс GUI для Pre-Processor Element, обозначающего действия, которые должны быть выполнены
перед отправкой запроса\\
\hline
AbstractVisualizer& Класс GUI для элемента Listener, предоставляющего возможность наблюдать результаты выполнения
запросов\\
\hline
AbstractTimerGui&Класс GUI для элемента Timer, предназначеннго для установки временных задержек между запуском
элементов Test Plan\\
\hline
\end{longtable}

Важным пунктом является реализация метода configure(TestElement el), который отвечает за отображение
параметров тестового элемента в GUI. Обратное действие --- передача данных из GUI в тестовый
элемент --- обеспечивается методом public void modifyTestElement(TestElement e),
который также нужно реализовать.

Другой необходимый в создании GUI метод --- createTestElement(). Он должен возвращать экземпляр нового
тестового элемента и передавать его в метод modifyTestElement(TestElement) в качестве параметра.

Все вышеобозначенные правила разграничения GUI и функционала элемента облегчают разработчикам реализацию графического
интерфейса. Хотя программист и не освобождается от процедуры создания и размещения компонентов графического
интерфейса, всё взаимодействие GUI и соответствующего ему тестового элемента обеспечивается JMeter.

\subsection{Реализация модуля отправки AMF сообщений}

Согласно одному из требований технического задания, разрабатываемое программное обеспечение должно предоставлять
возможность отправки AMF сообщения серверу. Данное требование осуществляется реализацией такого компонента, как
сэмплер. Сэмлеры в JMeter предназначены для отправки запросов серверу и получения ответов от них, на диаграмме
последовательности рис.~\ref{ris:Diagram4.png} предоставлены взаимодйствия основных объектов в учасвтующих в
семплировании.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{fig/development/Diagram4.png}}
\caption{Семплирование запросов}
\label{ris:Diagram4.png}
\end{figure}

Чтобы добавить свой собственный сэмплер в JMeter, необходимо создать класс, наследующий абстрактный класс AbstractSampler и 
реализующий метод sample(Entry e). Именно этот метод будет вызываться у каждого сэмплера, входящего в
тест план во время его теста. Метод sample должен осуществлять подключение к серверу, ожидание ответа от него и возвращать
экземпляр класса SampleResult, содержащий в себе информацию о выполнении запроса.

В рамках решения этой задачи был создан класс AmfRPCSampler. В методе sample данного класса производится вызов метода 
удалённого объекта на стороне сервера с помощью AMF клиента (алгоритм работы AMF клиента описан в разделе 3.2.3). 
Метод возвращает экземпляр класса AmfRPCSamplerResult, в который по ходу выполнения метода sample записывается информация 
о передаваемых в запросе данных, ответ сервера, а также статус выполнения запроса (в случае, если отсет сервера получен и 
не содержит сообщений обошибках, запрос считается успешно выполненным).

Также метод sample класса AmfRPCSampler отвечает за одно из важных технических требований к модулю --- возможность проведения 
полноценных нагрузочных тестов. В JMeter имитация работы с приложением большого числа пользователей одновременно осуществляется 
засчёт запуска тест-плана в несколько потоков и реализуемый сэмплер должен обеспечивать уникальность идентификатора сессии AMF 
клиента с сервером для каждого потока, выполняющего тест-план, а также гарантировать его сохранность в рамках одного потока. 
Данная задача решается засчёт введения в классе AmfRPCSampler статической переменной ThreadLocal.
Работа с данной переменной происходит следующим образом. В методе sample проверяется текущее значение AMFСonnection для
переменной ThreadLocal вызовом метода get(), который возвращает экземпяр AMFConnection для текущего потока.
Если соединение AMFConnection для данного потока уже было создано, то дальнейшая работа осуществляется с полученным экземпляром 
AMFConnection. Если вызов метода get() возвращает null, то создаётся новый экземпляр AMFConnection, производится попытка
подключения к серверу и значение AMFConnection записывается в переменную ThreadLocal. Таким образом все элементы AmfRPCSampler,
запускаемые одним потоком, будут работать с одним и тем же экземпляром AMFConnection, а остальные потоки будут использовать другие 
соединения.

Разработанный AmfRPCSampler также имеет графический интерфейс пользователя, реализованный в классе AmfRPCSamplerGui. AmfRPCSamplerGui 
создан согласно правилам реализации GUI в JMeter и расширяет класс AbstractSamplerGui. Интерфейс содержит следующие компоненты для ввода данных, 
необходимых для вызова метода объекта на стороне сервера:

\begin{enumerate}
\item endpointUrlField --- поле для URL, по которому отправляется запрос;
\item amfCallField --- поле для имени процедуы, которая должна быть вызвана; 
\item parametersPanel --- таблица параметров вызываемого метода.
\end{enumerate}

Графический интерфейс AmfRPCSampler изображён на Рис.~\ref{ris:amfSampler1.png}.

\begin{figure}[ht]
\center{\includegraphics[height=120mm, width=160mm]{fig/development/amfSampler1.png}}
\caption{Графический интерфейс элемента AMF RPC Sampler}
\label{ris:amfSampler1.png}
\end{figure}

\subsection{Реализация прокси-сервера}

Создание прокси-сервера необходимо для возможности записи трафика между приложением и сервером и дальнейшего использования 
записанных запросов в тест-плане. В рамках модуля в классе AmfHttpProxy реализован прокси сервер, который запускается по адресу
localhost:port (порт указывается ползователем), обрабатывает полученные http запросы и отправляет их адресату. 
В случае, если тело полученного http запроса содержит AMF сообщение, происходит его десериализация с использованием 
AmfMessageDeserializer и создаётся экземпляр 
AmfRPCSampler, в который записывается информация из AMF сообщения. Все созданные во время работы прокси-сервера AMF запросы 
могут быть перенесены в тест план. На Рис.~\ref{ris:Diagram1.png} изображена диаграмма последовательности, отображающая
процесса записи AMF запросов.

\begin{figure}[ht]
\center{\includegraphics[width=1\linewidth]{fig/development/Diagram1.png}}
\caption{Обработка запроса}
\label{ris:Diagram1.png}
\end{figure}

Прокси-сервер имеет графический интерфейс, реализованный в классе AMFProxyGui. GUI прокси-сервера содержит поле для
ввода порта, на котором сервер будет запущен, а также кнопки для запуска и остановки сервера (рис.~\ref{ris:proxySettings1.png})

\begin{figure}[ht]
\center{\includegraphics[height=120mm, width=160mm]{fig/development/proxySettings1.png}}
\caption{Интерфейс прокси-сервера}
\label{ris:proxySettings1.png}
\end{figure}

\section{Результаты реализации}

Результатом разработки в рамках дипломного проекта стал программный модуль, являющийся составным компонентом тестового
фреймворка Apache JMeter. Модуль расширяет базовую функциональность JMeter, а именно добавляет поддержку протокола AMF
засчёт введения новых элементов:

\begin{enumerate}
\item Amf RPC Sampler --- компонент, осуществляющий отправку AMF запросов серверу. Обеспечивает возможность отправки
 AMF запросов в несколько потоков. Имеет графический интерфейс,
позволяющий создавать и редактировать AMF сообщение;
\item AMF Proxy Server --- компонент, реализующий прокси-сервер и осуществляющий запись AMF запросов с целью их дальнейшего использования в тестах.
Данные обработанных AMF запросов помещаются в элемент Amf RPC Sampler. Имеет графический интерфейс, позволяющий задавать
порт прокси-сервера, осуществлять его запуск и остановку.
\end{enumerate}

\section{Тестирование}

Тестирование программного обеспечения --- проверка соответствия между реальным и ожидаемым поведением программы,
осуществляемая на конечном наборе тестов, выбранном определенным образом\cite{swebok}.
В более широком смысле, тестирование --- это одна из техник контроля качества, включающая в себя активности по
планированию работ (Test Management), проектированию тестов, выполнению тестирования и анализу полученных результатов.
Тестирование является важным и неотъемлемым этапом жизненного цикла программного обеспечения, оно позволяет выявить
ошибки уже на ранних стадиях разработки, что сокращает время разработки и повышает надежность программного продукта.
При разработке модуля использовались следующие виды тестирования:

\begin{enumerate}
\item Компонентное тестирование(Unit Testing);
\item Приёмочное тестирование.
\end{enumerate}

\subsection{Модульное тестирование}

Компонентное тестирование(Unit Testing) проверяет функциональность и ищет дефекты в частях
приложения, которые доступны и могут быть протестированы по-отдельности (модули программ, объекты, классы, функции
и т.д.)\cite{bek}. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно
быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных
местах программы, а также облегчает обнаружение и устранение таких ошибок. Цель модульного тестирования --- изолировать
отдельные части программы и показать, что по отдельности эти части работоспособны. Этот тип тестирования обычно
выполняется программистами\cite{stress}.

Во процессе реализации модуля было осуществлено покрытие классов, заключающих в себе основной функционал, юнит-тестами
(классы, реализующие GUI, тестами не покрывались). Тестирование проводилось с помощью JUnit ---  библиотеки для
модульного тестирования программного обеспечения на языке Java. Использование Maven в разработке приложения гарантирует,
что все созданные юнит-тесты будут автоматически запускаться перед сборкой модуля, и в случае, если хотя бы один тест не
выполнится, сборка приложения не будет запущена.

Как и любая технология тестирования, модульное тестирование не позволяет отловить все ошибки программы. В самом деле,
это следует из практической невозможности трассировки всех возможных путей выполнения программы, за исключением
простейших случаев. Кроме того, происходит тестирование каждого из модулей по отдельности. Это означает, что ошибки
интеграции, системного уровня, функций, исполняемых в нескольких модулях не будут определены. Кроме того, данная
технология бесполезна для проведения тестов на производительность. Таким образом, модульное тестирование более
эффективно при использовании в сочетании с другими методиками тестирования.

\subsection{Приёмочное тестирование}

Приемочное тестирование или Приемо-сдаточное испытание (Acceptance Testing) представляет собой формальный процесс
тестирования, который проверяет соответствие системы требованиям и проводится с целью:

\begin{enumerate}
\item определения удовлетворяет ли система приемочным критериям;
\item вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.
\end{enumerate}

Приемочное тестирование выполняется на основании набора типичных тестовых случаев и сценариев, разработанных на
основании требований к данному приложению.Решение о проведении приемочного тестирования принимается, когда:

\begin{enumerate}
\item продукт достиг необходимого уровня качества;
\item заказчик ознакомлен с Планом Приемочных Работ (Product Acceptance Plan);
\end{enumerate}

Фаза приемочного тестирования длится до тех пор, пока заказчик не выносит решение об отправлении приложения на
доработку или выдаче приложения.

План Приемочных Испытаний -  это документ, описывающий весь объем работ по тестированию, начиная с описания объекта,
стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования,
специальных знаний, а также оценки рисков с вариантами их разрешения.

Также важным этапом в подготовке приёмочного тестирования является проектирование тестовых случаев (Test Cases) ---
артефактов, описывающих совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации
тестируемой функции или её части. Чаще всего test case состоит из трёх частей:

\begin{enumerate}
\item предусловия --- список действий, которые приводят систему к состоянию пригодному для проведения основной
проверки, либо список условий, выполнение которых говорит о том, что система находится в пригодном для проведения
основного теста состоянии;
\item шаги теста --- список действий, переводящих систему из одного состояния в другое, для получения
результата, на основании которого можно сделать вывод о удовлетворении реализации, поставленным требованиям;
\item Expected Results --- описание состояния системы, в котором она должна находиться после выполнения шагов теста.
\end{enumerate}

Набор тестов должен быть спроектирован таким образом, чтобы обеспечивать оптимальное тестовое покрытие тестируемого
приложения.

\subsection{Результаты тестирования}

Разработанный программный модуль прошёл компонентное тестирование, а также приёмочные испытания. Результаты приёмочных
испытаний показали соответствие программного модуля требованиям, поставленным в техническом задании.

